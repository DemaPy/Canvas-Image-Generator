<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Placeholder Image</title>
  </head>
  <body>
    <canvas id="placeholderCanvas" width="650" height="300"></canvas>
    <br />
    <a id="downloadLink" download="placeholder_image.png"></a>
    <button id="download">Download</button>

    <div
      id="btns"
      style="
        display: flex;
        flex-direction: column;
        align-items: start;
        gap: 0.2rem;
        margin-top: 1rem;
      "
    ></div>
    <script>
      const images = [];
      const context = {
        options: {
          fontFamily: "Poppins, sans-serif",
          width: 650,
          height: 153,
          backgroundColor: "#FBF5F5",
        },
        name: {
          value: "20240916_01",
          letterCase: "lower",
        },
        data: {
          UK: [
            {
              value: "Dress your bed",
              options: {
                fontSize: "40",
                color: "#000",
              },
            },
            {
              value: "like a pro",
              options: {
                fontSize: "26",
                color: "#000",
              },
            },
          ],
        },
      };

      function createPlaceholderImage({ options, name }, suffix, textElems) {
        const canvas = document.getElementById("placeholderCanvas");
        const ctx = canvas.getContext("2d");
        // Parametry
        const width = options.width || 650;
        const height = options.height || 153;
        const backgroundColor = options.backgroundColor || "#FBF5F5"; // Tło
        const fontFamily = options.fontFamily || "Poppins, sans-serif"; // Czcionka (musisz mieć Poppins w systemie lub dodany do HTML)
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Ustawienie odstępu między liniami
        let yPos;
        const texts = [];

        // compute text position
        for (const [idx, item] of textElems.entries()) {
          // Środek, przesunięty w dół o połowę wysokości tekstu
          // PADDING HERE
          const yPos = (height - item.options.fontSize * 1.2) / 2;
          // Wyśrodkowane poziomo
          const xPos = width / 2;

          if (idx === 0) {
            texts.push({ value: item.value, x: xPos, y: yPos, item });
          } else {
            texts.push({
              value: item.value,
              x: xPos,
              y: yPos + textElems[idx - 1].options.fontSize * 1.2,
              item,
            });
          }
        }

        // compute paddings
        const computeHeight = texts.reduce((acc, item) => {
          acc += item.y;
          return acc;
        }, 0);

        // Ustawienie tła
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(0, 0, width, computeHeight);
        texts.forEach(({ value, x, y, item: { options } }) => {
          // Ustawienie czcionki i koloru tekstu
          ctx.fillStyle = options.color;
          ctx.font = `${options.fontSize}px ${fontFamily}`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(value, x, y); // Wyśrodkowane poziomo
        });

        images.push({
          name:
            "letterCase" in name
              ? name.letterCase === "lower"
                ? suffix.toLowerCase() + name.value.toLowerCase()
                : suffix.toUpperCase() + name.value.toUpperCase()
              : suffix + name.value,
          blob: canvas.toDataURL("image/jpg"),
        });
      }

      document.getElementById("download").addEventListener("click", () => {
        downloadImage();
      });

      function downloadImage() {
        const canvas = document.getElementById("placeholderCanvas");
        const link = document.getElementById("downloadLink");
        for (const [idx, element] of images.entries()) {
          setTimeout(() => {
            link.download = element.name;
            link.href = element.blob;
            link.click();
          }, 1000 * idx);
        }
      }

      for (const [k, v] of Object.entries(context.data)) {
        createPlaceholderImage(context, k, v);
      }
      renderImages(images);
      function renderImages(images) {
        const buttons = [];
        for (const { name, blob } of images) {
          const button = document.createElement("button");
          button.addEventListener("click", () => {
            const link = document.createElement("a");
            link.download = name;
            link.href = blob;
            link.click();
          });
          button.textContent = name;
          buttons.push(button);
        }

        document.body.querySelector("#btns").append(...buttons);
      }
    </script>
  </body>
</html>
